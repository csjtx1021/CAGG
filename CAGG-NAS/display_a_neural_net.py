#!/usr/bin/env/python
from __future__ import print_function, division
import os
import torch
from torch.nn import Sequential as Seq, Linear as Lin, ReLU, Tanh, LeakyReLU, BatchNorm1d as BN1
from torch.utils.data import Dataset,DataLoader
from torch.nn import functional as F, MSELoss, BCELoss
import time
import numpy as np
try:
    import cPickle
except ImportError:
    import pickle as cPickle

#this is same as data_utiles.py file
#
NODE_TYPES = [{"type":'ip',"hidden_num":0}, {"type":'op',"hidden_num":1}, {"type":'linear',"hidden_num":1}]
for i in [8,16,32,64,128,256,512,1024]:
    NODE_TYPES.append({"type":'relu',"hidden_num":i})
    NODE_TYPES.append({"type":'crelu',"hidden_num":i})
    NODE_TYPES.append({"type":'leaky-relu',"hidden_num":i})
    NODE_TYPES.append({"type":'softplus',"hidden_num":i})
    NODE_TYPES.append({"type":'elu',"hidden_num":i})
    NODE_TYPES.append({"type":'logistic',"hidden_num":i})
    NODE_TYPES.append({"type":'tanh',"hidden_num":i})

MAX_NODES = 20


def draw_a_net(filename,class_or_reg="reg"):
    
    try:
        #read from pkl file generated by python3 default protocol is 3
        pkl_file = open(filename, 'rb')
        input_g = cPickle.load(pkl_file)
        #rewrite it to pkl file so that it meets python2
        cPickle.dump(input_g, open("%s_forpython2read.pkl"%filename, 'wb'), protocol=2)
    except:
        input_g = cPickle.load(open("%s_forpython2read.pkl"%filename, 'rb'))
    
    
    x=input_g[0]
    edge_index=input_g[1]
    edge_attr=input_g[2]

    #nodes index
    nodes = [int(idx) for idx in torch.sum(x,-1).nonzero().view(-1).numpy()]

    nodetype=[]
    for idx in nodes:
        nodetype.append(NODE_TYPES[x[idx].nonzero().view(-1).item()])

    #print(input_g)

    reg_save_file_for_pres = os.path.join("results/", 'mlp_reg_%s'%(filename))
    
    from tools.nn.neural_network import MultiLayerPerceptron, get_mlp_layer_labels
    from tools.utils.general_utils import get_dok_mat_with_set_coords
    from tools.nn import nn_visualise

    all_layer_label_classes = get_mlp_layer_labels(class_or_reg)
    last_layer_label = 'linear' if class_or_reg == 'reg' else 'softmax'
    print(all_layer_label_classes)
    # Network 
    layer_labels = [i["type"] for i in nodetype] #
    num_units_each_layer =  [i["hidden_num"] for i in nodetype] #[None, 16, 16, 32, 64, None, None]
    for i in range(len(num_units_each_layer)):
        if layer_labels[i]=="ip" or layer_labels[i]=="op" or layer_labels[i]=="linear":
            num_units_each_layer[i]=None
    edges = [(int(a),int(b))for a,b in edge_index.t().numpy()]

    print(layer_labels,num_units_each_layer,edges)
    A = get_dok_mat_with_set_coords(edge_index.size(1), edges)

    #layer_labels = ['ip', 'softplus', 'elu', 'tanh', 'logistic', last_layer_label, 'op']
    #num_units_each_layer = [None, 16, 16, 32, 64, None, None]
    #A = get_dok_mat_with_set_coords(edge_index.size(1), [(0,1), (1,2), (2,3), (3,4), (4,5), (5,6)])

    mlp = MultiLayerPerceptron(class_or_reg, layer_labels, A,
                num_units_each_layer, all_layer_label_classes)
                
    nn_visualise.visualise_nn(mlp, reg_save_file_for_pres, for_pres=True)
  


#test
#1) python3 run to convert pkl file, maybe have some error, that is ok, then run
#2) python2 run to visual
if __name__ == "__main__":
    #filename="results/architecture_28_1.pkl"
    #filename="results/architecture_ours-soft-decode6_slice_31_1.pkl"
    #filename="results/architecture_ours-soft-decode6_slice_13_1.pkl"
    filename="results/architecture_ours-soft-decode6_slice_4_1.pkl"
    draw_a_net(filename,class_or_reg="reg")
